package edu.compscript.model.analisis;

// Importaciones principales.
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import edu.compscript.model.interprete.abstracto.Instruccion;
import edu.compscript.model.interprete.simbolo.*;
// Expresiones.
import edu.compscript.model.interprete.expresiones.*; // Aquí se encuentra la clase Nativo.
import edu.compscript.model.interprete.expresiones.operadores.aritmeticos.*;
import edu.compscript.model.interprete.expresiones.operadores.logicos.*;
import edu.compscript.model.interprete.expresiones.operadores.relacionales.*;
// Instrucciones.
import edu.compscript.model.interprete.instrucciones.*;
// Excepciones, errores.
import edu.compscript.model.interprete.excepciones.ErroresExpresiones;


parser code
{:
    Analizador s;
    parser(Analizador s) {this.s = s;}

    public LinkedList<ErroresExpresiones> erroresSintacticos = new LinkedList<>();

    // Errores recuperables.
    public void syntax_error(Symbol s) {
        erroresSintacticos.add(new ErroresExpresiones("SINTÁCTICO RECUPERABLE",
                    "No se esperaba el componente " + s.value,
                    s.left,
                    s.right));
    }

    // Errores no recuperables.
    public void unrecovered_syntax_error(Symbol s) {
        erroresSintacticos.add(new ErroresExpresiones("SINTÁCTICO NO RECUPERABLE",
                    "No se esperaba el componente "+s.value,
                    s.left,
                    s.right));
    }
:}

action code
{:
:}

terminal String CADENA, ENTERO, DECIMAL, ID;
terminal FIN_CADENA;
terminal INCREMENTO, DECREMENTO;
terminal MAS, MENOS, MULT, DIV, POW, ROOT, MOD;
terminal PARENT_IZQ, PARENT_DER, UMENOS;
terminal OR, AND, NOT;
terminal IGUALDAD, DIFERENTE, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
terminal CONSOLE, PUNTO, LOG;
terminal STRING, INT, DOUBLE, BOOLEANO, CARACTER;
terminal LET, CONST, DOS_PUNTOS, ASIGNACION;

//terminal LLAVE_IZQ, LLAVE_DER;

nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES;
nonterminal Boolean MUTABILIDAD;
nonterminal Instruccion INSTRUCCION, IMPRESION, DECLARACION, ASIGNACIONVAR;
nonterminal Instruccion AUTOINCREMENTO, AUTODECREMENTO;
nonterminal Instruccion EXPRESION;
nonterminal Tipo TIPOS;

//  Precedencias.
precedence left OR;
precedence left AND;
precedence right NOT;
precedence left IGUALDAD, DIFERENTE, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left MULT, DIV, MOD;
precedence nonassoc POW, ROOT;
precedence left INCREMENTO, DECREMENTO;
precedence right UMENOS;

start with INICIO;

// Escribir la gramatica.
INICIO ::= INSTRUCCIONES:a {: RESULT = a; :}
;

// TODO verificar con un if si lo que viene es un null (error), null no se puede agregar a una lista.
INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a {: RESULT = new LinkedList<Instruccion>(); RESULT.add(a); :}
;

INSTRUCCION ::= IMPRESION:a FIN_CADENA {: RESULT = a; :}
                | AUTOINCREMENTO:a FIN_CADENA {: RESULT = a; :}
                | AUTODECREMENTO:a FIN_CADENA {: RESULT = a; :}
                | DECLARACION:a FIN_CADENA {: RESULT = a; :}
                | ASIGNACIONVAR:a FIN_CADENA {: RESULT = a; :}
                | error FIN_CADENA {: RESULT = null; :}
;

AUTOINCREMENTO ::= ID:a INCREMENTO {: RESULT = new IncrementoExpresion(a, aleft, aright); :}
;
AUTODECREMENTO ::= ID:a DECREMENTO {: RESULT = new DecrementoExpresion(a, aleft, aright); :}
;

// <MUTABILIDAD> <ID> : <TIPO> ;
// <MUTABILIDAD> <ID> : <TIPO> = <EXPRESION> ;ö
// DeclaracionInstruccion(boolean mutabilidad, String id, Instruccion valor, Tipo tipo, int linea, int columna)ö
DECLARACION ::= MUTABILIDAD:a ID:b DOS_PUNTOS TIPOS:c {: RESULT = new DeclaracionInstruccion(a, b, null,c, bleft, bright); :}
                | MUTABILIDAD:a ID:b DOS_PUNTOS TIPOS:c ASIGNACION EXPRESION:d {: RESULT = new DeclaracionInstruccion(a, b, d, c, bleft, bright); :}
;

// AsignacionVariableInstruccion(String id, Instruccion valor, int linea, int columna)
ASIGNACIONVAR ::= ID:a ASIGNACION EXPRESION:b {: RESULT = new AsignacionVariableInstruccion(a, b, aleft, aright); :}
;

// ImprimirInstruccion(Instruccion expresion, int linea, int columna)
IMPRESION ::= CONSOLE PUNTO LOG PARENT_IZQ EXPRESION:a PARENT_DER {: RESULT = new ImprimirInstruccion(a, aleft, aright); :}
;

EXPRESION ::= MENOS EXPRESION:a {: RESULT = new NegacionUnariaExpresion(a, aleft, aright); :} %prec UMENOS
// OperacionAritmeticaExpresion(Instruccion operadorIzq, Instruccion operadorDer, int linea, int columna)
            | EXPRESION:a MAS EXPRESION:b {: RESULT = new SumaExpresion(a, b, aleft, aright); :}
            | EXPRESION:a MENOS EXPRESION:b {: RESULT = new RestaExpresion(a, b, aleft, aright); :}
            | EXPRESION:a MULT EXPRESION:b {: RESULT = new MultiplicacionExpresion(a, b, aleft, aright); :}
            | EXPRESION:a DIV EXPRESION:b {: RESULT = new DivisionExpresion(a, b, aleft, aright); :}
            | EXPRESION:a POW EXPRESION:b {: RESULT = new PotenciaExpresion(a, b, aleft, aright); :}
            | EXPRESION:a ROOT EXPRESION:b {: RESULT = new RaizExpresion(a, b, aleft, aright); :}
            | EXPRESION:a MOD EXPRESION:b {: RESULT = new ModuloExpresion(a, b, aleft, aright); :}
            // Operaciones lógicas
            | EXPRESION:a OR EXPRESION:b {: RESULT = new OrExpresion(a, b, aleft, aright); :}
            | EXPRESION:a AND EXPRESION:b {: RESULT = new AndExpresion(a, b, aleft, aright); :}
            | NOT EXPRESION:a {: RESULT = new NotExpresion(a, aleft, aright); :}
            // Operaciones relacionales
            | EXPRESION:a IGUALDAD EXPRESION:b {: RESULT = new IgualacionExpresion(a, b, aleft, aright); :}
            | EXPRESION:a DIFERENTE EXPRESION:b {: RESULT = new DiferenciacionExpresion(a, b, aleft, aright); :}
            | EXPRESION:a MENOR EXPRESION:b {: RESULT = new MenorQueExpresion(a, b, aleft, aright); :}
            | EXPRESION:a MENOR_IGUAL EXPRESION:b {: RESULT = new MenorIgualQueExpresion(a, b, aleft, aright); :}
            | EXPRESION:a MAYOR EXPRESION:b {: RESULT = new MayorQueExpresion(a, b, aleft, aright); :}
            | EXPRESION:a MAYOR_IGUAL EXPRESION:b {: RESULT = new MayorIgualQueExpresion(a, b, aleft, aright); :}

// Nativo(Object valor, Tipo tipo, int linea, int columna)
            | CADENA:a {: RESULT = new NativoExpresion(a, new Tipo(TipoDato.CADENA), aleft, aright); :}
            | ENTERO:a {: RESULT = new NativoExpresion(Integer.parseInt(a), new Tipo(TipoDato.ENTERO), aleft, aright); :}
            | DECIMAL:a {: RESULT = new NativoExpresion(new Double(a), new Tipo(TipoDato.DECIMAL), aleft, aright); :}
            //AccesoVariableExpresion(String id, int linea, int columna)
            | ID:a {: RESULT = new AccesoVariableExpresion(a, aleft, aright); :}
            | PARENT_IZQ EXPRESION:a PARENT_DER {: RESULT = a; :}
;

TIPOS ::= STRING {: RESULT = new Tipo(TipoDato.CADENA); :}
            | INT {: RESULT = new Tipo(TipoDato.ENTERO); :}
            | DOUBLE {: RESULT = new Tipo(TipoDato.DECIMAL); :}
            | BOOLEANO {: RESULT = new Tipo(TipoDato.BOOLEANO); :}
            | CARACTER {: RESULT = new Tipo(TipoDato.CARACTER); :}
;

MUTABILIDAD ::= LET {: RESULT = true; :}
                | CONST {: RESULT = false; :}
;